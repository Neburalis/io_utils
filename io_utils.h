#ifndef IO_UTILS_H
#define IO_UTILS_H

#include <stdio.h>
#include <stdlib.h>
#include "ansi.h"

// Открывает новую "альтернативную" сессию терминала (альтернативный буфер экрана)
// После этого весь вывод будет идти в отдельный буфер, не затрагивая основной
#define TERMINAL_ENTER_ALT_SCREEN() \
    do { \
        fputs("\033[?1049h", stdout); \
        fflush(stdout); \
    } while (0)

// Возвращает терминал в исходную сессию (основной буфер экрана)
// При этом восстанавливается содержимое терминала, каким оно было до ENTER_ALT_SCREEN
#define TERMINAL_EXIT_ALT_SCREEN() \
    do { \
        fputs("\033[?1049l", stdout); \
        fflush(stdout); \
    } while (0)

// Очищает текущий экран терминала (очищает всё содержимое и перемещает курсор в левый верхний угол)
#define TERMINAL_CLEAR_SCREEN() \
    do { \
        fputs("\033[2J\033[H", stdout); \
        fflush(stdout); \
    } while (0)

/**
 * @brief Макрос с ASCII-артом для отображения сообщения об ошибке времени выполнения.
 *
 * Содержит красиво оформленную строку "RUNTIME ERROR" в виде ASCII-арта,
 * окруженную декоративными символами. Используется для визуального выделения
 * критических ошибок времени выполнения.
 */
#define RUNTIME_ERROR_BIG_STRING "\n" \
  " .+\"+.+\"+.+\"+.+\"+.+\"+.+\"+.+\"+.+\"+.+\"+.+\"+.+\"+.+\"+.+\"+.+\"+.+\"+.+\"+.+\"+.+\"+.+\"+.+\"+.+\"+. \n" \
  "(      ____  _   _ _   _ _____ ___ __  __ _____   _____ ____  ____   ___  ____        )                     \n" \
  " )    |  _ \\| | | | \\ | |_   _|_ _|  \\/  | ____| | ____|  _ \\|  _ \\ / _ \\|  _ \\      (               \n" \
  "(     | |_) | | | |  \\| | | |  | || |\\/| |  _|   |  _| | |_) | |_) | | | | |_) |      )                   \n" \
  " )    |  _ <| |_| | |\\  | | |  | || |  | | |___  | |___|  _ <|  _ <| |_| |  _ <      (                     \n" \
  "(     |_| \\_\\\\___/|_| \\_| |_| |___|_|  |_|_____| |_____|_| \\_\\_| \\_\\\\___/|_| \\_\\      )          \n" \
  " )                                                                                   (                      \n" \
  "(                                                                                     )                     \n" \
  " \"+.+\"+.+\"+.+\"+.+\"+.+\"+.+\"+.+\"+.+\"+.+\"+.+\"+.+\"+.+\"+.+\"+.+\"+.+\"+.+\"+.+\"+.+\"+.+\"+.+\"+.+\"\n\n"

/**
 * @brief Макрос-напоминание о необходимости зафиксировать изменения в GitHub.
 *
 * Выводит цветное ASCII-сообщение "Don't forget commit GitHub" с использованием
 * ANSI-кодов для выделения. Служит напоминанием разработчику о необходимости
 * сохранения изменений в системе контроля версий.
 */
#define DONT_FORGET_COMMIT_GITHUB()                                                 \
  printf(BOLD(CYAN("\n"                                                             \
    " ____              _ _      __                      _                       \n"\
    "|  _ \\  ___  _ __ ( ) |_   / _| ___  _ __ __ _  ___| |_                    \n"\
    "| | | |/ _ \\| '_ \\|/| __| | |_ / _ \\| '__/ _` |/ _ \\ __|                \n"\
    "| |_| | (_) | | | | | |_  |  _| (_) | | | (_| |  __/ |_                     \n"\
    "|____/ \\___/|_| |_|  \\__| |_|  \\___/|_|  \\__, |\\___|\\__|              \n"\
    "                               _ _      _|___/ _   _   _       _            \n"\
    "  ___ ___  _ __ ___  _ __ ___ (_) |_   / ___(_) |_| | | |_   _| |__         \n"\
    " / __/ _ \\| '_ ` _ \\| '_ ` _ \\| | __| | |  _| | __| |_| | | | | '_ \\    \n"\
    "| (_| (_) | | | | | | | | | | | | |_  | |_| | | |_|  _  | |_| | |_) |       \n"\
    " \\___\\___/|_| |_| |_|_| |_| |_|_|\\__|  \\____|_|\\__|_| |_|\\__,_|_.__/  \n\n"\
  )));

/**
 * @brief Макрос для отладочного вывода, работающий только в режиме _DEBUG.
 *
 * В режиме отладки (_DEBUG определен) выводит форматированное сообщение
 * в stderr и принудительно сбрасывает буфер. В release-режиме не выполняет
 * никаких действий (компилируется в пустоту).
 *
 * @param ... Параметры форматирования, аналогично fprintf().
 *
 * @note Автоматически добавляет fflush(stderr) для немедленного вывода.
 * @note В release-сборке полностью исключается из кода.
 */
#ifdef _DEBUG
  #warning "_DEBUG is ENABLED"
  #define DEBUG_PRINT(...)                           \
  fprintf(stderr, __VA_ARGS__); fflush(stderr);
#else
  #define DEBUG_PRINT(...) (void)0
#endif

/**
 * @brief Макрос для вывода детального сообщения об ошибке с информацией о местоположении.
 *
 * Выводит красиво отформатированное сообщение об ошибке, включающее:
 * - Имя файла и номер строки (зеленым цветом)
 * - Имя функции (желтым цветом)
 * - Пользовательское сообщение с форматированием
 * - Системное описание ошибки через perror()
 *
 * @param format Строка формата для пользовательского сообщения (как в printf).
 * @param ... Аргументы форматирования.
 *
 * @note Использует ANSI-коды для цветного вывода в терминал.
 * @note Автоматически добавляет системное описание последней ошибки.
 */
#define ERROR_MSG(format, ...)                                                  \
    fprintf(stderr,                                                             \
            "MEOW\nIn " GREEN("%s:%d") ", " YELLOW("%s") ".\n" format,          \
            __FILE__, __LINE__, __PRETTY_FUNCTION__, ##__VA_ARGS__); perror(""); fflush(stderr);

/**
 * @brief Показывает GIF-файл с использованием системного просмотрщика.
 *
 * На macOS использует команду qlmanage для быстрого просмотра GIF-анимации.
 * Файл должен находиться в директории cat_gifs/.
 *
 * @param[in] filename Имя файла без расширения .gif. Не может быть NULL.
 *                    Полный путь формируется как "cat_gifs/{filename}.gif".
 *
 * @note Функция работает только на macOS. На других платформах не выполняет действий.
 * @note При ошибке устанавливает errno = EINVAL если filename == NULL.
 */
void show_gif(const char * const filename);

/**
 * @brief Показывает случайный GIF-файл из переданного массива имен файлов.
 *
 * Использует arc4random_uniform() для выбора случайного элемента из массива
 * и вызывает show_gif() для его отображения.
 *
 * @param[in] n Количество элементов в массиве filenames. Должно быть > 0.
 * @param[in] filenames Массив указателей на строки с именами файлов.
 *                     Не может быть NULL.
 *
 * @note Функция работает на macOS. На других платформах не выполняет действий.
 * @note При ошибке устанавливает errno = EINVAL если n == 0 или filenames == NULL.
 */
void show_random_gif(size_t n, const char ** filenames);

/**
 * @brief Приостанавливает выполнение программы на заданное количество миллисекунд.
 *
 * Использует nanosleep() для точного ожидания. Устойчива к прерываниям сигналами
 * (EINTR) - продолжает ожидание до полного завершения времени.
 *
 * @param[in] msec Количество миллисекунд для ожидания. Должно быть >= 0.
 *
 * @return 0 при успешном выполнении, -1 при ошибке.
 * @note При msec < 0 устанавливает errno = EINVAL и возвращает -1.
 */
int msleep(long msec);

/**
 * @brief Приостанавливает выполнение программы на заданное количество наносекунд.
 *
 * Использует nanosleep() для точного ожидания. Устойчива к прерываниям сигналами
 * (EINTR) - продолжает ожидание до полного завершения времени.
 *
 * @param[in] nsec Количество наносекунд для ожидания. Должно быть >= 0.
 *
 * @return 0 при успешном выполнении, -1 при ошибке.
 * @note При nsec < 0 устанавливает errno = EINVAL и возвращает -1.
 */
int nsleep(size_t nsec);

/**
 * @brief Показывает анимированный спиннер с заданным текстом.
 *
 * Отображает вращающийся индикатор прогресса в виде символов '-', '\', '|', '/'.
 * Каждый символ показывается в течение заданного периода.
 *
 * @param[in] str Текст для отображения перед спиннером. Не может быть NULL.
 * @param[in] time Общее время показа спиннера в миллисекундах.
 * @param[in] period Период смены символов спиннера в миллисекундах.
 *
 * @note При str == NULL устанавливает errno = EINVAL.
 * @note Использует '\r' для возврата каретки и обновления анимации.
 */
void spinner(const char * const str, uint32_t time, uint32_t period);

/**
 * @brief Подсчитывает количество строк в открытом файле.
 *
 * Сканирует файл, подсчитывая символы '\n'. После подсчета возвращает
 * указатель файла в начало с помощью fseek().
 *
 * @param[in] fp Указатель на открытый файл. Не может быть NULL.
 *
 * @return Количество строк в файле (минимум 1, если файл не пустой).
 *         При ошибке возвращает 0 и устанавливает errno = EBADF.
 *
 * @note Файл должен быть открыт для чтения.
 * @note После выполнения указатель файла возвращается в начало.
 */
size_t lines_in_file(FILE *fp);

/**
  @brief Функция отчистки буфера ввода
  Считывает данные из потока ввода до \\n (\n также будет считан)

  \code{cpp}
    int a = 0;
    a = getchar();

    clear_stdin_buffer();
    // Теперь буфер чист
  \endcode

  @return int 1 если буфер отчищен
 */
int clear_stdin_buffer();

/**
  @brief Функция проверки чист ли буфер ввода (очищает буфер если он чист)
  Считывает данные из потока ввода до \\n (\n также будет считан)
  Если считывается ' ' или '\t' - то считается что буфер чист
  Если считывается любое другое, считается что буфер не чист


  \code{cpp}
    int a = 0, status = 0;
    a = getchar();

    if (is_stdin_buffer_clean())
        // В буфере были только ' ' и '\t' теперь чист
    else
        // В буфере есть что-то еще, он остался не чист
  \endcode

  @return int 1 если буфер содержал только ' ' или '\t' или уже был чист
  @return int 0 если буфер содержит что-то помимо пустоты
 */
int is_stdin_buffer_clean();

/**
 * @brief Безопасный ввод числа double с проверками и обработкой ошибок.
 *
 * Запрашивает у пользователя ввод числа с плавающей точкой. При некорректном
 * вводе показывает сообщение об ошибке, GIF с котиком и просит повторить ввод.
 * Проверяет корректность формата, конечность числа и чистоту буфера ввода.
 *
 * @param[in] prompt Приглашение для ввода (например, "Введите число: ").
 *                  Не может быть NULL.
 *
 * @return Корректно введенное конечное число типа double.
 * @return NAN если ввод был завершен (EOF) или при ошибке параметров.
 *
 * @note Функция выполняется в цикле до получения корректного ввода или EOF.
 * @note При некорректном вводе показывает случайный GIF из cat_gifs/.
 * @note Ожидает десятичный разделитель-точку (.).
 */
double safe_get_double(const char * const var_name);

/**
 * @brief Запрашивает у пользователя подтверждение действия (y/n).
 *
 * Показывает сообщение пользователю и ожидает ввода символа подтверждения.
 * Принимает 'y', 'Y' как согласие и 'n', 'N' как отказ.
 *
 * @param[in] ask_message Сообщение для пользователя (например, "Продолжить? (y/n): ").
 *                       Не может быть NULL.
 *
 * @return 1 если пользователь ввел 'y' или 'Y' (согласие).
 * @return 0 если пользователь ввел 'n', 'N' или '\n' (отказ).
 * @return -1 при ошибке (ask_message == NULL, устанавливается errno = EINVAL).
 *
 * @note Функция игнорирует все символы кроме y, Y, n, N и \n.
 */
int is_user_want_continue(const char * const ask_message);

/**
 * @brief Определяет размер файла в байтах.
 *
 * Использует системный вызов stat() для получения информации о файле
 * и возвращает его размер в байтах.
 *
 * @param[in] filename Путь к файлу. Не может быть NULL.
 *
 * @return Размер файла в байтах (ssize_t) при успехе.
 * @return -1 при ошибке получения информации о файле (errno устанавливается stat()).
 * @return -2 при невалидных параметрах (filename == NULL, errno = EINVAL).
 *
 * @note Файл не обязательно должен быть открыт - функция работает с путем к файлу.
 */
ssize_t file_byte_size(const char * const filename);

/**
 * @brief Читает содержимое файла в выделяемый буфер.
 *
 * Функция:
 * - Открывает файл в бинарном режиме.
 * - Определяет его размер через file_byte_size().
 * - Выделяет буфер размером (размер_файла + 1) байт с помощью calloc().
 * - Читает ровно столько байт, сколько вернул file_byte_size().
 * - Добавляет завершающий нулевой байт '\0' в конец буфера.
 * - Возвращает указатель на буфер и записывает его длину (включая '\0') в buf_len.
 *
 * @attention
 * - Возвращаемый буфер завершён нулём и пригоден для использования как C-строка,
 *   даже если файл бинарный.
 * - Вызывающий код обязан освободить память через free().
 * - Значение *buf_len — это **реальный размер выделенного буфера**, включая '\0'.
 *
 * @param[in] filename Имя файла для чтения. Не может быть NULL.
 * @param[out] buf_len Указатель на переменную, куда будет записана длина выделенного буфера
 *                     (в байтах, включая завершающий '\0'). Не может быть NULL.
 *
 * @return Указатель на выделенный буфер в случае успеха, или NULL в случае ошибки.
 *         При ошибке errno устанавливается соответствующим образом:
 *         - EINVAL — если переданы невалидные аргументы,
 *         - другие значения — от fopen(), file_byte_size(), malloc().
 * @attention Вызывающий код обязан освободить память через free().
 */

char * read_file_to_buf(const char * const filename, size_t * const buf_len);

/**
 * @brief Читает бинарный файл в буфер size_t значений.
 *
 * Открывает файл в бинарном режиме, проверяет, что его размер кратен sizeof(size_t),
 * выделяет память и читает содержимое как массив size_t значений.
 *
 * @param[in] filename Путь к бинарному файлу для чтения. Не может быть NULL.
 * @param[out] count Указатель на переменную для записи количества прочитанных
 *                  size_t элементов. Не может быть NULL.
 *
 * @return Указатель на выделенный буфер с данными при успехе, или NULL при ошибке.
 *         При ошибке errno устанавливается соответствующим образом:
 *         - EINVAL — невалидные параметры или размер файла не кратен sizeof(size_t),
 *         - EFBIG — файл слишком большой,
 *         - другие — от fopen(), fstat(), malloc(), fread().
 *
 * @attention Вызывающий код обязан освободить память через free().
 * @attention Файл должен содержать данные в формате size_t (бинарный формат).
 */
size_t * read_file_to_size_t_buf(const char *filename, size_t *count);

#endif // IO_UTILS_H
